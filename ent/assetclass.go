// Code generated by ent, DO NOT EDIT.

package ent

import (
	"dig-inv/ent/assetclass"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

// AssetClass is the model entity for the AssetClass schema.
type AssetClass struct {
	config `json:"-"`
	// ID of the ent.
	// The unique identifier for the asset class.
	ID uuid.UUID `json:"id,omitempty"`
	// The name of the asset class, which is used to identify it in the inventory system.
	Name string `json:"name,omitempty"`
	// A description of the asset class, which can be used to provide additional information about the asset class.
	Description string `json:"description,omitempty"`
	// An icon representing the asset class, which can be used in the user interface to visually distinguish different asset classes.
	Icon string `json:"icon,omitempty"`
	// A color associated with the asset class, which can be used in the user interface to visually distinguish different asset classes.
	Color string `json:"color,omitempty"`
	// The provider of the asset class, which is used to identify the provider of the asset class. This is used to determine which provider's table to use for storing additional information about the asset class.
	Provider string `json:"provider,omitempty"`
	// The user who created the resource in the inventory system. This is used for auditing purposes and to track who added the resource.
	CreatedBy string `json:"created_by,omitempty"`
	// When the resource was created in the inventory system.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// The user who last updated the resource in the inventory system. This is used for auditing purposes and to track who modified the resource.
	UpdatedBy string `json:"updated_by,omitempty"`
	// The time when the resource was last updated in the inventory system.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// The user who deleted the resource from the inventory system. This is used for auditing purposes and to track who removed the resource.
	DeletedBy string `json:"deleted_by,omitempty"`
	// The time when the resource was deleted from the inventory system.
	DeletedAt        *time.Time `json:"deleted_at,omitempty"`
	item_asset_class *uuid.UUID
	selectValues     sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*AssetClass) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case assetclass.FieldName, assetclass.FieldDescription, assetclass.FieldIcon, assetclass.FieldColor, assetclass.FieldProvider, assetclass.FieldCreatedBy, assetclass.FieldUpdatedBy, assetclass.FieldDeletedBy:
			values[i] = new(sql.NullString)
		case assetclass.FieldCreatedAt, assetclass.FieldUpdatedAt, assetclass.FieldDeletedAt:
			values[i] = new(sql.NullTime)
		case assetclass.FieldID:
			values[i] = new(uuid.UUID)
		case assetclass.ForeignKeys[0]: // item_asset_class
			values[i] = &sql.NullScanner{S: new(uuid.UUID)}
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the AssetClass fields.
func (ac *AssetClass) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case assetclass.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				ac.ID = *value
			}
		case assetclass.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				ac.Name = value.String
			}
		case assetclass.FieldDescription:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field description", values[i])
			} else if value.Valid {
				ac.Description = value.String
			}
		case assetclass.FieldIcon:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field icon", values[i])
			} else if value.Valid {
				ac.Icon = value.String
			}
		case assetclass.FieldColor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field color", values[i])
			} else if value.Valid {
				ac.Color = value.String
			}
		case assetclass.FieldProvider:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field provider", values[i])
			} else if value.Valid {
				ac.Provider = value.String
			}
		case assetclass.FieldCreatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field created_by", values[i])
			} else if value.Valid {
				ac.CreatedBy = value.String
			}
		case assetclass.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				ac.CreatedAt = value.Time
			}
		case assetclass.FieldUpdatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field updated_by", values[i])
			} else if value.Valid {
				ac.UpdatedBy = value.String
			}
		case assetclass.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				ac.UpdatedAt = value.Time
			}
		case assetclass.FieldDeletedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_by", values[i])
			} else if value.Valid {
				ac.DeletedBy = value.String
			}
		case assetclass.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				ac.DeletedAt = new(time.Time)
				*ac.DeletedAt = value.Time
			}
		case assetclass.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field item_asset_class", values[i])
			} else if value.Valid {
				ac.item_asset_class = new(uuid.UUID)
				*ac.item_asset_class = *value.S.(*uuid.UUID)
			}
		default:
			ac.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the AssetClass.
// This includes values selected through modifiers, order, etc.
func (ac *AssetClass) Value(name string) (ent.Value, error) {
	return ac.selectValues.Get(name)
}

// Update returns a builder for updating this AssetClass.
// Note that you need to call AssetClass.Unwrap() before calling this method if this AssetClass
// was returned from a transaction, and the transaction was committed or rolled back.
func (ac *AssetClass) Update() *AssetClassUpdateOne {
	return NewAssetClassClient(ac.config).UpdateOne(ac)
}

// Unwrap unwraps the AssetClass entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ac *AssetClass) Unwrap() *AssetClass {
	_tx, ok := ac.config.driver.(*txDriver)
	if !ok {
		panic("ent: AssetClass is not a transactional entity")
	}
	ac.config.driver = _tx.drv
	return ac
}

// String implements the fmt.Stringer.
func (ac *AssetClass) String() string {
	var builder strings.Builder
	builder.WriteString("AssetClass(")
	builder.WriteString(fmt.Sprintf("id=%v, ", ac.ID))
	builder.WriteString("name=")
	builder.WriteString(ac.Name)
	builder.WriteString(", ")
	builder.WriteString("description=")
	builder.WriteString(ac.Description)
	builder.WriteString(", ")
	builder.WriteString("icon=")
	builder.WriteString(ac.Icon)
	builder.WriteString(", ")
	builder.WriteString("color=")
	builder.WriteString(ac.Color)
	builder.WriteString(", ")
	builder.WriteString("provider=")
	builder.WriteString(ac.Provider)
	builder.WriteString(", ")
	builder.WriteString("created_by=")
	builder.WriteString(ac.CreatedBy)
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(ac.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_by=")
	builder.WriteString(ac.UpdatedBy)
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(ac.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("deleted_by=")
	builder.WriteString(ac.DeletedBy)
	builder.WriteString(", ")
	if v := ac.DeletedAt; v != nil {
		builder.WriteString("deleted_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteByte(')')
	return builder.String()
}

// AssetClasses is a parsable slice of AssetClass.
type AssetClasses []*AssetClass
