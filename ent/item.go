// Code generated by ent, DO NOT EDIT.

package ent

import (
	"dig-inv/ent/item"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

// Item is the model entity for the Item schema.
type Item struct {
	config `json:"-"`
	// ID of the ent.
	// The unique identifier for the item, which is used to track the item in the inventory system. This is a UUID that is generated when the item is created.
	ID uuid.UUID `json:"id,omitempty"`
	// The name of the item, which is used to identify it in the inventory system.
	Name string `json:"name,omitempty"`
	// A description of the item, which can be used to provide additional information about the item.
	Description string `json:"description,omitempty"`
	// The type of the item, which is used to identify the provider of the item. This is used to determine which provider's table to use for storing additional information about the item.
	Type string `json:"type,omitempty"`
	// The provider of the item, which is used to identify the provider of the item. This is used to determine which provider's table to use for storing additional information about the item.
	Provider string `json:"provider,omitempty"`
	// The user who created the resource in the inventory system. This is used for auditing purposes and to track who added the resource.
	CreatedBy string `json:"created_by,omitempty"`
	// When the resource was created in the inventory system.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// The user who last updated the resource in the inventory system. This is used for auditing purposes and to track who modified the resource.
	UpdatedBy string `json:"updated_by,omitempty"`
	// The time when the resource was last updated in the inventory system.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// The user who deleted the resource from the inventory system. This is used for auditing purposes and to track who removed the resource.
	DeletedBy string `json:"deleted_by,omitempty"`
	// The time when the resource was deleted from the inventory system.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ItemQuery when eager-loading is set.
	Edges        ItemEdges `json:"edges"`
	tag_items    *uuid.UUID
	selectValues sql.SelectValues
}

// ItemEdges holds the relations/edges for other nodes in the graph.
type ItemEdges struct {
	// The tags that are associated with this item. This edge represents the many-to-many relationship between items and tags, allowing multiple tags to be associated with a single item and vice versa.
	Tags []*Tag `json:"tags,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// TagsOrErr returns the Tags value or an error if the edge
// was not loaded in eager-loading.
func (e ItemEdges) TagsOrErr() ([]*Tag, error) {
	if e.loadedTypes[0] {
		return e.Tags, nil
	}
	return nil, &NotLoadedError{edge: "tags"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Item) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case item.FieldName, item.FieldDescription, item.FieldType, item.FieldProvider, item.FieldCreatedBy, item.FieldUpdatedBy, item.FieldDeletedBy:
			values[i] = new(sql.NullString)
		case item.FieldCreatedAt, item.FieldUpdatedAt, item.FieldDeletedAt:
			values[i] = new(sql.NullTime)
		case item.FieldID:
			values[i] = new(uuid.UUID)
		case item.ForeignKeys[0]: // tag_items
			values[i] = &sql.NullScanner{S: new(uuid.UUID)}
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Item fields.
func (i *Item) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for j := range columns {
		switch columns[j] {
		case item.FieldID:
			if value, ok := values[j].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[j])
			} else if value != nil {
				i.ID = *value
			}
		case item.FieldName:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[j])
			} else if value.Valid {
				i.Name = value.String
			}
		case item.FieldDescription:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field description", values[j])
			} else if value.Valid {
				i.Description = value.String
			}
		case item.FieldType:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field type", values[j])
			} else if value.Valid {
				i.Type = value.String
			}
		case item.FieldProvider:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field provider", values[j])
			} else if value.Valid {
				i.Provider = value.String
			}
		case item.FieldCreatedBy:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field created_by", values[j])
			} else if value.Valid {
				i.CreatedBy = value.String
			}
		case item.FieldCreatedAt:
			if value, ok := values[j].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[j])
			} else if value.Valid {
				i.CreatedAt = value.Time
			}
		case item.FieldUpdatedBy:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field updated_by", values[j])
			} else if value.Valid {
				i.UpdatedBy = value.String
			}
		case item.FieldUpdatedAt:
			if value, ok := values[j].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[j])
			} else if value.Valid {
				i.UpdatedAt = value.Time
			}
		case item.FieldDeletedBy:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_by", values[j])
			} else if value.Valid {
				i.DeletedBy = value.String
			}
		case item.FieldDeletedAt:
			if value, ok := values[j].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[j])
			} else if value.Valid {
				i.DeletedAt = new(time.Time)
				*i.DeletedAt = value.Time
			}
		case item.ForeignKeys[0]:
			if value, ok := values[j].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field tag_items", values[j])
			} else if value.Valid {
				i.tag_items = new(uuid.UUID)
				*i.tag_items = *value.S.(*uuid.UUID)
			}
		default:
			i.selectValues.Set(columns[j], values[j])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Item.
// This includes values selected through modifiers, order, etc.
func (i *Item) Value(name string) (ent.Value, error) {
	return i.selectValues.Get(name)
}

// QueryTags queries the "tags" edge of the Item entity.
func (i *Item) QueryTags() *TagQuery {
	return NewItemClient(i.config).QueryTags(i)
}

// Update returns a builder for updating this Item.
// Note that you need to call Item.Unwrap() before calling this method if this Item
// was returned from a transaction, and the transaction was committed or rolled back.
func (i *Item) Update() *ItemUpdateOne {
	return NewItemClient(i.config).UpdateOne(i)
}

// Unwrap unwraps the Item entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (i *Item) Unwrap() *Item {
	_tx, ok := i.config.driver.(*txDriver)
	if !ok {
		panic("ent: Item is not a transactional entity")
	}
	i.config.driver = _tx.drv
	return i
}

// String implements the fmt.Stringer.
func (i *Item) String() string {
	var builder strings.Builder
	builder.WriteString("Item(")
	builder.WriteString(fmt.Sprintf("id=%v, ", i.ID))
	builder.WriteString("name=")
	builder.WriteString(i.Name)
	builder.WriteString(", ")
	builder.WriteString("description=")
	builder.WriteString(i.Description)
	builder.WriteString(", ")
	builder.WriteString("type=")
	builder.WriteString(i.Type)
	builder.WriteString(", ")
	builder.WriteString("provider=")
	builder.WriteString(i.Provider)
	builder.WriteString(", ")
	builder.WriteString("created_by=")
	builder.WriteString(i.CreatedBy)
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(i.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_by=")
	builder.WriteString(i.UpdatedBy)
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(i.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("deleted_by=")
	builder.WriteString(i.DeletedBy)
	builder.WriteString(", ")
	if v := i.DeletedAt; v != nil {
		builder.WriteString("deleted_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteByte(')')
	return builder.String()
}

// Items is a parsable slice of Item.
type Items []*Item
